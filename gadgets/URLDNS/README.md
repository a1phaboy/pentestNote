这是我gadgets分析的第一篇文章，关于URLDNS链的相关分析。代码来源于ysoserial。

### 分析

在ysoserial调用到URLDNS模块时，会实例化一个hashMap的类并返回。

![image-20220722142906615](image-20220722142906615.png)

在返回之前，hashMap把URL对象和传入的url字符串作为key，value值绑定进了map中，我们跟进hashMap的put函数

![image-20220722143313650](image-20220722143313650.png)

跟进putVal函数中，发现putVal函数都在根据hash值来进行相对应处理，那么hash值是怎么来的？我们跟进一下hash函数

![image-20220722143635737](image-20220722143635737.png)

静态方法hash中，会对传入的key值做判断，如果不为空，就进行key这个对象的hashcode方法，在这里我们传入的key值其实是一个URL对象，并且也不为空，由此可以跟进URL的hashcode方法。

![image-20220722143859236](image-20220722143859236.png)

在此会对hashcode这个值做判断，如果是-1的话调用handler的hashcode方法，在此的handler其实是我们通过`URL u = new URL(null, url, handler);`URL构造函数传进去的handler，也就是URLStreamHandler，所以也就是调用的是URLStreamHandler的hashcode，对hashcode进行跟进。

![image-20220722144320934](image-20220722144320934.png)

可以很明显看到调用了getHostAddress方法去进行DNS请求，至此分析完成。



### 问题

1. 作者为什么要重写类？

   其实在handler那个地方已经讲过了，会调用handler的hashcode方法从而进一步进行DNS请求，在此作者用了URLStreamHandler的子类，并重写父类的openConnection方法和getHostAddress方法，可以看到返回为空，也就是在本地调用了`ht.put`方法时，不会向url进行DNS请求。

### 思考

从整条gedget可以看出，在调用hash方法前，都是利用到的hashMap的相关方法，hash方法其实是根据key对应的类不同而不同，在此由于key是URL类，并且URL类对于hashcode为-1会进行特殊的处理（发送请求DNS来重新计算hashcode）。这正好给予我们探测是否存在可序列化漏洞的信号。